一、迭代器模式(Iterator):
    1、与for循环相较，Iterator将遍历与实现分离开来，并不会依赖某个具体类
    2、所需角色：
        a. 迭代器(Iterator)：定义遍历接口
        b. 迭代器实现类(ConcreteIterator)：实现遍历接口，与对应的集合类对接(需注意，对接的是集合类，而不是集合类中的集合)
        c. 集合(Aggregate)：定义迭代器对接类的规范，保证Iterator能正常运行
        d. 集合实现类(ConcreteIterator)：实现相关规范
    3、实现流程：
        a. 实现对应的集合类，提供 获取集合长度getLength() 和 获取对应元素get(int index) 的方法
        b. 实现对应的Iterator类，依据集合类提供的方法进行填充
    4、优点：
        就算对接类改变了存储的数据结构，Iterator类和业务代码都无需更改逻辑


二、适配器模式(Adapter):
    1、在 `需求` 和 `实际情况` 之间中转、填补两者的差异
    2、所需角色：
        a. Target(对象)：定义需求
        b. Client(请求者)：调用需求接口的一方
        c. Adaptee(被适配)：实际存在的可选择方法
        d. Adapter(适配器)：调和需求接口和可选择方法的实现类
    3、实现流程：
        a. `需求` 接口化
        b. `实际情况` 对应实际存在的方法
        c. 适配器就是实现需求接口，将对应的方法填入
        ps. 适配时，实现方法可以用继承获取，也可以直接调用其他类(一般不用继承，过于受限)
    4、优点：
        当需求的具体实现内容更改时，只需修改适配器，而不用动接口和实际存在的方法
    5、缺点：
        策略模式似乎比适配器模式更加适合解耦，待议


三、模板模式(TemplateMethod)：将具体处理交由子类
    1、定义：在父类中定义处理流程的框架，在子类中实现具体处理的模式，即为TemplateMethod模式
    2、所需角色：
        a. AbstractClass(抽象类)：实现模板方法，并且定义模板中所需使用的抽象方法
        b. ConcreteClass(具体类)：实现抽象类中定义的抽象方法
    3、操作流程：
        a. 定义抽象类，规范流程，定义所需的抽象方法，规范流程
        b. 依据实际情况，在具体类实现抽象类中的方法
    4、优点：
        a. 可以使逻辑处理通用化
        b. 使父类和子类保持一致性
        c. 子类在满足基本规范的同时，也能够实现拓展
    5、缺点：
        a. 父类抽象类规范难以平衡，过多的抽象类会降低子类的灵活性，过少则容易使得子类中的实现方法变得臃肿，甚至混乱不堪


四、工厂模式(FactoryMethod)：将实例的生成交由子类
    1、定义：父类中决定实例的生成方式，但并不决定要生成的类，具体的处理交由子类负责
    2、所需角色：
        a. Product(产品)：属于框架的一方，规定在该模式中，需要符合Product规范的类才能成为操作处理的对象
        b. Creator(创建者)：属于框架的一方，只需定义要调用的类(指Product)和要用什么方法，但具体的实现类和具体方法不必关心
        c. ConcreteProduct(具体产品)：具体加工的一方，决定了具体的产品
        d. ConcreteCreator(具体创建者)：具体加工的一方，决定具体的实现流程
    3、操作流程：
        a. 定义好相应的 产品接口 和 工厂接口
        b. 实现需要的所有 产品类
        c. 工厂类实现，按逻辑输出对应的 产品类
    4、优点：
        a. 当产品类极易拓展，只需新增产品符合 产品规范 和 生产规范，就可以直接在工厂实现类中进行配置


五、单例模式(Singleton)：程序运行时，该类始终只有一个实例
    1、定义：保证在程序中始终只有一个该类的实例的模式，即为单例模式
    2、所需角色：单例单例，就是只有对象类独一个
    3、操作流程：
        a. 构造器私有化
        b. 类内自声明
        c. 公有化接口暴露，保证只有单个实例可以被引用
    4、优点：
        a. 保证程序中始终只有一个实例


六、原型模式(Prototype)：通过复制生成实例
    1、定义：不根据类，而是根据实例来生成新的实例的模式。一般用于对象种类太多、难以根据类生成实例或想对框架和实例进行解耦时。
    2、所需角色：
        a. Prototype(原型)：定义复制现有实例来生成新实例的方法的接口
        b. ConcretePrototype(具体原型)：实现生成新实例的方法
        c. Client(使用者)：集中管理原型，并在使用者中调用clone()方法对原型进行复制，进而产生新实例
    3、操作流程：
        a. 定义原型接口，设置原型相关规范，以及clone()
        b. 实现Client启动器，用以装载原型集合，并调用clone()生成对应的克隆
        c. 实现原型，实现clone()
    4、优点：
        a. 整合多种应用场景，在类型繁多且频繁应用时，不用多次创建实例
        b. 容易生成难以根据类生成相应的实例
        c. 可自定义生成指令字段，不会受限于原有的Class，便于解耦框架和生成的实例


七、建造者模式(Builder)：组装复杂的实例
    1、定义：使用多个简单的对象一步一步构建成一个复杂的对象的模式，即为建造者模式
    2、所需角色：
        a. Builder(建造者)：负责定义 生成实例的 接口(API)
        b. ConcreteBuilder(具体建造者)：实现Builder接口，同时可能会实现返回最终结果的方法
        c. Director(监工)：调用Builder接口，利用接口中的方法进行加工，最终完成实例
        d. Client(使用者)：选择具体的Builder填入Director进行加工
    3、操作流程：
        a. 定义Builder接口，规范相关方法
        b. 创建Director类，实现操作流程
        c. 按需实现Builder接口
        d. 按需获取相应的Builder实现类，填入Director类中进行
    4、优点：
        a. 可以在Director类中实现对Builder类的隐藏(利用protected和静态常量)，并且Director类泛用Builder接口，
            使得添加Builder的实现类时，Client几乎无需变动
    5、注意点：
        a. 工厂模式是按需生产，适用于多种类产品的场景(重点是多种类)
        b. 建造者模式是规定组装次序，适用于复杂产品生产的场景(重点是生产流程复杂，各步骤都有差异)
        c. 模板模式则是只是给定模板，使用者直接调用模板实现类，而不会经由Director进行规范


八、抽象工厂模式(AbstractFactory)：将关联零件组装成产品
    1、定义：将抽象零件组装为抽象产品的工厂模式，即将具体工厂抽象化的模式，即为抽象工厂模式
    2、所需角色：
        a. AbstractProduct(抽象产品)：定义AbstractFactory所生成的抽象产品 的接口(API)
        b. AbstractFactory(抽象工厂)：定义生成抽象产品的接口
        c. Client(使用者)：调用 AbstractFactory 进行生产 AbstractProduct ，无需知晓用的是哪个具体工厂类，生产的是哪种产品
        d. ConcreteProduct(具体产品)：实现AbstractProduct接口
        e. ConcreteFactory(具体工厂)：实现AbstractFactory接口
    3、操作流程：
        a. 定义好相应的 工厂类 和 产品类 接口,并在工厂接口中实现选择具体工厂的方法
        b. 实现具体的 工厂类 和 产品类
    4、优点：
        a. 易于增加新的工厂
    5、缺点：
        a. 难以增加新的产品，产品类型一作变动，所有的工厂类都需变动


九、桥接模式(Bridge)：将类的功能层次结构和实现层次结构分离
    1、定义：把抽象化与实现化解耦，使得二者可以独立变化的模式，即为桥接模式
    2、所需角色：
        a. Abstraction(抽象化)：位于功能层次结构的最上层，其中保存Implementor实例以保证基本功能
        b. RefinedAbstraction(改善后的抽象化)：功能层次下层，新增功能
        c. Implementor(实现者)：位于实现层次结构的最上层，定义了Abstraction的接口
        d. ConcreteImplementor(具体实现者)：实现Implementor接口，可满足多个实现层次
    3、操作流程：
        a. 定义Implementor接口
        b. 按需对Implementor进行一次或多次实现
        c. 实现Abstraction类，在类中调用Implementor接口
        d. 按需对Abstraction进行功能扩展
    4、优点：
        a. 功能和实现的结构层次分离后，更有利于独立地对应用场景进行扩展
    5、缺点：
        a. 增加代码理解难度
    6、注意点：需理解 继承 和 委任 的关联程度不同，在桥接模式中委任接口就是为了降低耦合度


十、策略模式(Strategy)：整体地替换算法
    1、定义：一种行为型模式，可以根据不同的场景，切换不同的运算逻辑的设计模式，即为策略模式
    2、所需角色：
        a. Strategy(策略)：定义实现策略所需的API
        b. ConcreteStrategy(具体策略)：实现具体策略
        c. Context(上下文)：规范Strategy的使用规则
    3、操作流程：
        a. 定义Strategy接口
        b. 按需实现策略
        c. 实现Context类
    4、优点：
        a. 配置灵活，可根据不同的场景执行不同的策略
    5、注意点：
        a. Builder决定的是最终生成的实例,而Strategy决定的是行为实现逻辑
        b. Adapter只是按接口需求替换实现方法，适用于大部分应用场景可复用时作特殊逻辑处理。但由于没有Context，容易造成代码混乱
        c. Strategy则是整体进行替换，适用于大部分应用场景都不相同时作配置，容易管理，但是应对同一应用场景复用时容易出问题


十一、组合模式(Composite)：容器与内容的一致性
    1、定义：使容器和内容物具有一致性，创造出递归结果的模式，即为组合模式
    2、所需角色：
        a. Leaf(内容物)：基元，不能放入其他角色
        b. Composite(复合物)：容器，可放入Leaf和其他Composite
        c. Component：规范接口，使得Leaf和Composite保有一致性
        d. Client：启动器，实现Composite树的遍历
    3、操作流程：
        a. 定义Component接口，确定一致性
        b. 实现基元
        c. 实现Composite，确立Leaf和Composite的交互关系
    4、优点：
        a. 树形结构，具有普适性


十二、装饰器模式(Decorator)：装饰边框和装饰物的一致性(相当于蛋糕外层套个礼盒，再包一层包装纸)
    1、定义：允许向现有对象添加新功能，同时又不改变其结构的设计模式，即为装饰器模式。是结构模式。
    2、所需角色：
        a. Component(核心组件)：增加功能时的核心角色的定义接口
        b. ConcreteComponent(具体核心组件)：核心角色的实现类
        c. Decorator(装饰物)：装饰物的定义接口，定义装饰物所要装饰的核心角色
        d. ConcreteDecorator(具体装饰物)：装饰物的实现类。需注意，装饰物 = 核心角色 + 装饰品，装饰物本质也是核心角色
    3、操作流程：
        a. 定义要进行操作的核心类接口
        b. 实现最基本的核心类
        c. 定义与核心类对接的装饰物接口，保证经由装饰后的装饰物仍是核心类
        d. 实现装饰物
    4、优点：
        a. API具有透明性，不管核心类被装饰过多少次，其API依旧不变
        b. 可以动态地增加功能，可按需实现装饰品，并且可以对同一核心类进行多次装饰
        c. 用委托进行装饰操作，弱关联使得同一装饰品可以装饰多个核心类
    5、缺点：
        a. 过多的装饰类会使得代码膨胀，并且难以在逻辑中进行约束和管理


十三、访问者模式(Visitor)：访问数据结构并处理数据
    1、定义：针对数据结构，将数据结构和对其的处理分离开来的设计模式，即为访问者模式。是行为模式。
    2、所需角色：
        a. Visitor(访问者)：接口，声明visit()，定义Visitor所能访问的Element
        b. ConcreteVisitor(具体访问者)：实现Visitor接口
        c. Element(元素)：接口，声明accept()，定义所能接受的Visitor
        d. ConcreteElement(具体元素)：实现Element接口
        e. ObjectStructure(对象结构)：负责处理Element角色的对象集合
    3、操作流程：
        a. 定义Element，并实现ObjectStructure，确立所需元素
        b. 定义Visitor并按需实现visit()
        c. Element实现accept()
    4、优点：
        a. 将 处理逻辑 和 存储用的数据结构 分离开来，应注意数据结构理应只负责将元素和集合关联起来，但不负责处理
        b. 提高了 元素 和 对象结构 作为组件的独立性
        c. 符合开闭原则(现有类不修改，可创建新类扩展)，数据结构不被修改，而Visitor允许扩展功能
    5、缺点：
        a. 负责处理逻辑的Visitor容易扩展，但负责存储的Element难以增加
            每增加一个Element，都需在Visitor接口声明相应的方法，并在Visitor对应的子类中一一实现


十四、责任链模式(Chain of Responsibility)：推卸责任
    1、定义：为请求者创建一个接收者对象的链，对请求的发送者和接收者进行解耦的模式，即为责任链模式。是行为模式。
    2、所需角色：
        a. Handler(处理者)：定义了处理请求的接口，并声明调用链的next
        b. ConcreteHandler(具体处理者)：实现Handler，按需实现具体处理逻辑
        c. Client(请求者)：请求发送者
    3、操作流程：
        a. 明确请求
        b. 定义Handler，按需实现
    4、优点：
        a. 弱化请求发送者和接收者之间的关系，并且降低管理成本，提升组件的独立性和可复用性
        b. 可动态地改变责任链，按需配置
    5、缺点：
        a. 由于多层嵌套，所以处理时会产生延迟


十五、外观模式(Facade)：简单窗口
    1、定义：将关联在一起、错综复杂的类整合成高层的接口(API),而系统内部各个类的责任关系和依赖关系会被完全封装
    2、所需角色：
        a. Facade(窗口)：代表构成系统许多其他角色的简单窗口，向外层提供API
        b. 其他角色：构筑系统流程，它们之间互相调用，但一定不会去调用Facade
        c. Client(请求者)：负责调用Facade角色
    3、操作流程：
        a. 封装系统内不必要暴露的接口
        b. 提供Facade类，整合其他接口，提供API
    4、优点：
        a. 使API变少，方便调用和维护
        b. 在庞大的系统中，递归使用Facade容易避免代码堆积


十六、仲裁者模式(Mediator)：裁决集中
    1、定义：给多个对象提供一个中介类，用以处理不同对象之间的通信，并支持松耦合，使得代码容易维护。属于行为型模型
    2、所需角色：
        a. Mediator(裁决者)：负责定义与Colleague进行通信和做出决定的接口(API)
        b. ConcreteMediator(具体裁决者)：实现Mediator接口的具体流程
        c. Colleague(参与者)：负责定义与Mediator进行通信的接口
        d. ConcreteColleague(具体参与者)：实现Colleague接口
    3、操作流程：
        a. 按需划分Colleague
        b. 定义并实现对应的Mediator，规定相应的通信接口
        c. 将各个Colleague与Mediator进行绑定
        d. Mediator按相应的场景，通过通信接口与Colleague进行指挥
    4、优点：
        a. 流程集中化，便于日后bug的排查
        b. 通信集中管理，便于拓展


十七、观察者模式(Observer)：发送状态变化通知
    1、定义：当观察对象状态发生变化时，会通知给观察者。适用于根据对象状态进行相应处理的场景。属于行为型模型
    2、所需角色：
        a. Subject(观察对象)：定义了设定观察者和移除观察者的方法，以及定义相应的通知接口
        b. ConcreteSubject(具体观察对象)：实现具体的观察对象
        c. Observer(观察者)：接收来自Subject的状态变化通知，定义update()进行对应的处理
        d. ConcreteObserver(具体观察者)：实现具体的观察者
    3、操作流程：
        a. 确定场景，确立观察对象(可能有多个)
        b. 设置观察者(可能有多个)
        c. 将二者进行关联
    4、优点：
        a. 观察者和观察对象都具有可替换性
    5、注意点：
        a. 观察者的update()操作应尽量不要引起观察对象的状态变化，否则容易造成死循环
    6、区别：
        a. Observer是被动接受状态变化的数据
        b. Visitor则是主动进入对象中获取所需数据，从而进一步进行处理


十八、备忘录模式(Memento)：保存对象的状态
    1、定义：引入表示实例状态的角色，用以防止在保存和恢复实例时破坏对象的封装性。属性行为型模型
    2、所需角色：
        a. Originator(生成者)：需要进行备份的对象，相当于本体
        b. Memento(备份)：Originator在各个阶段下的备份，一般不会向外部公开这些信息
            可分为 wide interface：用于Originator的数据恢复
                   narrow interface：对外提供信息，通过合理封装，防止泄密
        c. Caretaker(负责人)：对Originator和Memento进行调控
    3、优点：
        a. 能够有效封装，保证了程序的容错性
        b. 合理利用Java的封装特性，保证了信息安全


十九、状态模式(State)：用类表示状态
    1、定义：用类来表示对象的状态（正常来说是在类中判定状态，再实现相应的逻辑），属于行为型模型
    2、所需角色：
        a. State(状态)：定义了需要按不同状态进行处理的方法的API
        b. ConcreteState(具体状态)：实现各个具体状态下的处理流程
        c. Context(上下文)：定义供外部使用State模式的接口
    3、操作流程：
        a. 确立上下文，明晰细化流程
        b. 划分状态，分辨哪些流程需要进行区分
        c. 在状态类中，实现上下文中的细化流程
        d. 在上下文中暴露接口，供给外部使用状态类
    4、优点：
        a. 分而治之，当减少if-else的使用，方便程序的管理
        b. 依赖状态进行处理，即是将状态抽象出来，实现了拓展和复用
    5、注意点：
        a. 状态的迁移可以放在State中，进一步的封装方便阅读
            也可以放在Context中，提升State的独立性，明晰程序的整体结构


二十、享元模式(Flyweight)：共享对象，避免浪费
    1、定义：通过共享实例来避免新的实例化的设计模式，即为享元模式。属于结构型模式
    2、所需角色：
        a. Flyweight(轻量级)：表示被共享的类
        b. FlyweightFactory(轻量级工厂)：生成并存储Flyweight的类
        c. Client(请求者)：使用FlyweightFactory生成Flyweight的角色
    3、操作流程：
        a. 确立享元类
        b. 生成工厂进行存储
        c. 调用
    4、优点：
        a. 所有享元类都是共享的，只要该类改变了，所有相关的应用都会改变
            应确立好什么可以共享，什么不可以共享
    5、注意点：
        a. 需注意不要让被共享的实例被GC


二十一、代理模式(Proxy)：只在必要时生成实例
    1、定义：使用一个类调用另一个类功能的设计模式，即为代理模式。属于结构型模型
    2、所需角色：
        a. Subject(主体)：定义了ConcreteSubject和Proxy之间具有一致性的接口，保证程序在无需刻意去
            使用ConcreteSubject或Proxy的情况下也能正常执行
        b. Proxy(代理人)：Proxy会优先处理请求。只有在必要的情况下，才会生成ConcreteSubject并交付工作
        c. ConcreteSubject(实际主体)：操作流程最后的保证，不在必要的情况下不会被实例化
        d. Client(请求者)：使用Proxy的角色
    3、优点：
        a. 减少实例的生成，确保执行效率


二十二、命令模式(Command)：命令也是类
    1、定义：整合工作的历史纪录，并使得命令能够随时调用的设计模式，即为命令模式。属于行为型模型
    2、所需角色：
        a. Command(命令)：负责定义执行的API
        b. ConcreteCommand(具体的命令)：实现API
        c. Receiver(接收者)：Command执行操作时所交付的对象
        d. Invoker(发动者)：执行命令的角色
    3、优点：
        a. 保存了命令纪录，方便复用
        b. 明确执行边界(将具体执行操作放在Command中，Receiver中只存在其固有方法)


二十三、解释器模式(Interpreter)：语法规则也是类
    1、定义：提供利用语言和语法进行修改方法的设计模式，即为解释器模式。属于行为型模型
    2、所需角色：
        a. AbstractExpression(抽象表达式)：定义语法树节点的共同接口(API)，是针对某个字段进行处理的逻辑
        b. TerminalExpression(终结符表达式)：定义终结符表达式的处理逻辑
        c. NonTerminalExpression(非终结符表达式)：定义非终结表达式的处理逻辑
        d. Context(上下文)：语法的解释器，提供了语法的解释规则。是对语句进行解析拆封的逻辑处理
        e. Client(请求者)：只调用总的表达式和解释器进行编译的角色
    3、优点：
        a. 有效的封装了程序，方便调用